## Go

实现数据抽象和面向对象的途径极其灵活

自动化的内存管理

箴言：不要通过共享内存来通信，而应该通过通信来共享内存

### 特性

slice ， 

#### defer

- 当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行

- 可以在一个函数中执行多条defer语句，执行顺序与声明顺序相反

  > 释放资源的defer应该直接跟在请求资源的语句后

  ```go
  resp, err := http.Get(url)
  if err != nil {
    return err
  }
  defer resp.Body.close()
  ```

- 延迟执行的defer函数可以改变外层函数返回给调用者的结果

简单性

### 并发

Goroutine和Channel

#### Goroutine

主函数返回时，所有的goroutine都暴力的直接终结

> 在go中，每一个并发的执行单元叫作一个goroutine

以服务端和客户端为例，并发分两个层面，首先是服务可以处理多个客户端的请求，其次是在单个客户端的连接中也存在并发

go关键字申明goroutine，go后跟的函数的参数会在go语句自身执行时被求值

顺序通信进程CSP：并发模式，在不同的执行体间传递值

- [ ] goroutine和线程的本质区别

#### Channel

- 通道基本语法：

```go
ch := make(chan xxx) //申明，内置函数make创建一个通道，类型是（chan xxx）
ch <- some_value //发送操作
<- ch //接收操作
close(ch) //内置函数close关闭通道
```

结束时关闭每个通道不是必须的:

1. 通知完接收方所有数据已经发送完才需要关闭

2. 垃圾回收是根据是否可以访问来决定回收通道，而不是根据它是否关闭

   

- 单向通道：

```go
chan<- int //只能发送通道，该变量只能出现在<-左侧
<-chan int //只能接收通道，该变量只能出现在<-右侧
```



任何操作中将双向通道转成单向通道都是可行的，反之不行

- 缓冲通道

  创建通道时通过make的容量参数来设定

  ```go
  ch = make(chan string, 3)
  ```

- 并行循环

1. 无缓存通道
2. todo

- 多路复用

  使用场景，可以对不同事件选择性进行响应，不会block后续流程，使用slecte可以实现对channel轮询

  > 当goroutine一直尝试向一个没有goroutine从中读取值的channel发送事件，被称为goroutine泄漏

### 基于共享变量的并发



#### 数据竞态

两个及以上goroutine并发读写同一个变量，并且至少其中有一个是写入时，称为数据竞态

避免数据竞态的三种方法：

1. 不要修改变量，只读取，不写入
2. 避免从多个goroutine访问变量
3. 互斥机制，允许多个goroutine访问同一个变量，但在同一时间，只允许一个goroutine可以访问

#### 互斥锁

#### 读写互斥锁

写锁是否需要抢占读锁，不然在写入时如何保持读的一致性，还是说允许读在一定程度上的延迟与之后

#### 延迟初始化

`sync.Once`,`Once`包含一个布尔变量和一个互斥量，布尔变量记录初始化步骤是否已经完成，互斥量则负责保护这个布尔变量和客户端的数据结构

#### 并发非阻塞缓存

- [ ] 如何在防止竞态的情况下，同时不损耗性能的优化，不把预期中并行的操作串行化



## RUST

注重性能、并行、内存安全

java的垃圾回收：Jvm在java程序运行期间，必须时刻监控、遍历java对象树，以鉴别出堆上哪些变量不再被引用，在一定的时间周期到达时自动释放那些不被引用变量的内存。

即Jvm 在运行着一个和实际程序完全无关的垃圾回收进程，为运行时开销

### RUST的内存管理

#### 所有权系统

- 作用域

  Rust的每个对象都实现了一个名为`Drop`的trait（可以理解为java的 接口），`Drop`包含一个方法`drop()`，在任何对象离开作用域的时候，`drop`会被自动调用，从而释放自身的内存

- 转移

  `move`副本拷贝

- 借用

  - 只读借用

    `&`地址**借**用（更准确的理解是borrow，而非refer）

    

  - 可变借用

    `&mut`，可变借用可以对数据进行修改，前提是借用的值是可以更改的

  > 可以有多个只读借用，但是只能有一个可变借用（可变借用期间也禁止只读借用，不允许拥有者有任何操作）

