## Go

实现数据抽象和面向对象的途径极其灵活

自动化的内存管理

箴言：不要通过共享内存来通信，而应该通过通信来共享内存

### 特性

slice ， 

#### defer

- 当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行

- 可以在一个函数中执行多条defer语句，执行顺序与声明顺序相反

  > 释放资源的defer应该直接跟在请求资源的语句后

  ```go
  resp, err := http.Get(url)
  if err != nil {
    return err
  }
  defer resp.Body.close()
  ```

- 延迟执行的defer函数可以改变外层函数返回给调用者的结果

简单性

### 并发

Goroutine和Channel

#### Goroutine

主函数返回时，所有的goroutine都暴力的直接终结

> 在go中，每一个并发的执行单元叫作一个goroutine

以服务端和客户端为例，并发分两个层面，首先是服务可以处理多个客户端的请求，其次是在单个客户端的连接中也存在并发

go关键字申明goroutine，go后跟的函数的参数会在go语句自身执行时被求值

顺序通信进程CSP：并发模式，在不同的执行体间传递值

- [ ] goroutine和线程的本质区别

#### Channel

- 通道基本语法：

```go
ch := make(chan xxx) //申明，内置函数make创建一个通道，类型是（chan xxx）
ch <- some_value //发送操作
<- ch //接收操作
close(ch) //内置函数close关闭通道
```

结束时关闭每个通道不是必须的:

1. 通知完接收方所有数据已经发送完才需要关闭

2. 垃圾回收是根据是否可以访问来决定回收通道，而不是根据它是否关闭

   

- 单向通道：

```go
chan<- int //只能发送通道，该变量只能出现在<-左侧
<-chan int //只能接收通道，该变量只能出现在<-右侧
```



任何操作中将双向通道转成单向通道都是可行的，反之不行

- 缓冲通道

  创建通道时通过make的容量参数来设定

  ```go
  ch = make(chan string, 3)
  ```

- 并行循环

1. 无缓存通道
2. todo

- 多路复用

  使用场景，可以对不同事件选择性进行响应，不会block后续流程，使用slecte可以实现对channel轮询

  > 当goroutine一直尝试向一个没有goroutine从中读取值的channel发送事件，被称为goroutine泄漏

### 基于共享变量的并发



#### 数据竞态

两个及以上goroutine并发读写同一个变量，并且至少其中有一个是写入时，称为数据竞态

避免数据竞态的三种方法：

1. 不要修改变量，只读取，不写入
2. 避免从多个goroutine访问变量
3. 互斥机制，允许多个goroutine访问同一个变量，但在同一时间，只允许一个goroutine可以访问

#### 互斥锁

#### 读写互斥锁

写锁是否需要抢占读锁，不然在写入时如何保持读的一致性，还是说允许读在一定程度上的延迟与之后

#### 延迟初始化

`sync.Once`,`Once`包含一个布尔变量和一个互斥量，布尔变量记录初始化步骤是否已经完成，互斥量则负责保护这个布尔变量和客户端的数据结构

#### 并发非阻塞缓存

- [ ] 如何在防止竞态的情况下，同时不损耗性能的优化，不把预期中并行的操作串行化



## RUST

注重性能、并行、内存安全



java的垃圾回收：Jvm在java程序运行期间，必须时刻监控、遍历java对象树，以鉴别出堆上哪些变量不再被引用，在一定的时间周期到达时自动释放那些不被引用变量的内存，即Jvm 在运行着一个和实际程序完全无关的垃圾回收进程，为运行时开销



**所有权系统**是Rust最为与众不同的特性，它保证了RUST无需垃圾回收即可保障内存安全，来一探究竟吧



### RUST的内存管理

更直接的，rust如何回收堆和栈上的数据，存储在栈上的数据好理解，当离开作用域时被移出栈，那rust是如何回收堆上的数据呢，拥有内存的变量离开作用域时，内存被自动释放

#### 所有权系统

**所有权**是一个新的概念，它由三条所有权规则来定义：

1. Rust中的每一个值都有一个被称为其所有者的变量
2. 值有且只有一个所有者
3. 当所有者（变量）离开作用域，这个值将被丢弃

两次释放相同内存会导致内存污染，rust会在拷贝被分配的内存时，将原变量标记为不再有效，这个操作称为移动

> 只拷贝指针、长度和容量而不拷贝数据看起来像是浅拷贝，rust所做的与此略有差异，同时会使原变量失效

如果复制的行为和clone没有区别，就没必要调用clone，比如对栈上的数据的复制



- [ ] 既然rust的每一个对象都已经实现了`Drop`，那么如何为类型增加`Copy`注解呢（这个问题目前暂时不会更新，等待9-15日的空闲时间再同步一下进度吧）

  

- 作用域

  Rust的每个对象都实现了一个名为`Drop`的trait（可以理解为java的 接口），`Drop`包含一个方法`drop()`，在任何对象离开作用域的时候，`drop`会被自动调用，从而释放自身的内存

- 转移

  `move`副本拷贝

- 借用

  - 只读借用

    `&`地址**借**用（更准确的理解是borrow，而非refer）;

    借用对象而不是获取对象的所有权，使用值但不获取所有权（所有权定义？），当借用离开作用域时其指向的值不会被**丢弃**（抑或说释放）;

    函数签名需要使用`&`来表明参数的类型是一个借用;

    在函数中，无法对借用的变量进行更改，如果需要更改的话，就需要使用可变借用；

    一个借用的作用域从声明的地方开始一直持续到最后一次使用为止
  
  - 可变借用
  
    `&mut`，可变借用可以对数据进行修改，前提是借用的值是可以更改的;
    
    可以有多个只读借用，但是**在特定作用域中的特定数据有且只有一个可变引用**（可变借用期间也禁止只读借用，不允许拥有者有任何操作）;
    
    在变量已经有只读借用的前提下，不同同时拥有可变借用
  
  - 悬垂引用(借用)
  
    在具有指针的语言中，释放内存时经常会有错误的保留仍这块内存的指针，指针指向的内容可能已经被分配给其他持有者
  
  总而言之，明确两点，一是在任意指定时间内，要么只能有一个可变借用，要么只能有多个不可变借用，二是引用必须总是有效

### 生命周期



## python

- [ ] python的竞态，并发通信怎么做的

一直没有好好探索python语言设计的初衷与特点，趁着这篇文章分享一下相关的认知及观点