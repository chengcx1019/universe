安全并高效的处理并发编程是**Rust**的另一个主要目标，那么不妨来看一下，Rust在并发编程方面有哪些得天独厚的设计，与之相对的**Java**，**Go**，**Python**在并发编程的设计是怎样的。



严格来讲，并发和并行是不同的行为，但是在讲清楚“编程语言在并发处理上的设计”这个问题上严格区分这两个概念并没有显著的帮助，并且会带来理解的额外信息量，因而在讲到并发时，大家在脑海中可以用严格意义上的**并发和并行**替换。



不进行区分不代表要模糊概念，还是要做到心中有数，理解为什么可以不加区分的进行论述。在大部分现代操作系统中，执行中程序的代码运行于一个 **进程**（*process*）中，操作系统则负责管理多个进程。进程是组织资源的最小单位,而线程是安排 CPU 执行的最小单位。

在程序内部，也可以拥有多个同时运行的独立部分。这个运行这些独立部分的功能被称为 **线程**（*threads*）。更严谨来说**并发**是不同线程分时共享一个CPU**交错执行**，**并行**是不同线程在不同CPU下**同时执行**，不管是同一进程下的线程，还是不同进程下的线程，需要着重说明的是，由于CPU执行的最小单元是线程，在多核机器上，同一进程下的多线程是可以出现并行的，但是不管线程并发还是并行执行，需要共同面对的一些问题：

* 竞争状态（Race conditions），多个线程以不一致的顺序访问数据或资源

* 死锁（Deadlocks），两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行

* 只会发生在特定情况且难以稳定重现和修复的 bug

  

回到我们的约定，为了论述简洁性，本文不严格区分并发和并行，**线程并行**可以理解为**多CPU下的线程并发**，以下统称为并发。



编程语言通常有两种方式来实现并发：

- 消息传递并发
- 共享状态并发

其中容易出现问题的是共享状态的并发，典型的是数据竞态问题。



## Rust

起初，Rust 团队认为确保内存安全和防止并发问题是两个分别需要不同方法应对的挑战。随着时间的推移，团队发现所有权和类型系统是一系列解决内存安全 **和** 并发问题的强有力的工具。

Rust选择了在编译阶段就杜绝了数据竞态问题



## Go

Go语言有一句箴言：**不要通过共享内存来通信，而应该通过通信来共享内存**



## Python

很多人知道Pyhton有全局解释器锁GIL，Python为什么要加GIL，其实是为了解决代码在解释执行时的一致性问题，保证多个线程在同一时刻不会修改同一数据，并且在同一时刻所看到的数据值是相同的，GIL保证同时只能有一个线程可以执行，自然就保证了这个限制，但是很尴尬的是，GIL是一个进程锁，是用作互斥线程的机制，这就导致python支持创建多线程，但是不支持同时执行多个线程，由于GIL的存在，同一时刻，只有一个线程可以向前执行，但是不能在设计层面上避免竞态问题，不同线程交替执行，也可能对共享数据进行写操作，GIL只是保证了解释器层面的一致性，但是程序的数据一致性，需要开发者采用补充机制去控制，比如加锁等。



## Java

要理解Java