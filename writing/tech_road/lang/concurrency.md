安全并高效的处理并发编程是 **Rust** 的另一个主要目标，那么不妨来看一下，Rust在并发编程方面有哪些得天独厚的设计，与之相对的 **Java**，**Go**，**Python** 在并发编程的设计是怎样的。



严格来讲，并发和并行是不同的行为，但是在讲清楚“编程语言在并发处理上的设计”这个问题上严格区分这两个概念并没有显著的帮助，并且会带来理解的额外信息量，因而在讲到并发时，大家在脑海中可以用严格意义上的**并发和并行**替换。



不进行区分不代表要模糊概念，还是要做到心中有数，理解为什么可以不加区分的进行论述。在大部分现代操作系统中，执行中程序的代码运行于一个 **进程**（process）中，操作系统则负责管理多个进程。进程是组织资源的最小单位,而线程是安排 CPU 执行的最小单位。

在程序内部，也可以拥有多个同时运行的独立部分。这个运行这些独立部分的功能被称为 **线程**（*threads*）。更严谨来说**并发**是不同线程分时共享一个CPU**交错执行**，**并行**是不同线程在不同 CPU 下**同时执行**，不管是同一进程下的线程，还是不同进程下的线程，需要着重说明的是，由于CPU执行的最小单元是线程，在多核机器上，同一进程下的多线程是可以出现并行的，但是不管线程并发还是并行执行，需要共同面对的一些问题：

* 竞争状态（Race conditions），多个线程以不一致的顺序访问数据或资源

* 死锁（Deadlocks），两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行

* 只会发生在特定情况且难以稳定重现和修复的问题

  

回到我们的约定，为了论述简洁性，本文不严格区分并发和并行，**线程并行**可以理解为**多CPU下的线程并发**，以下统称为并发。



编程语言通常有两种方式来实现并发：

- 消息传递并发
- 共享状态并发

其中容易出现问题的是共享状态的并发，典型的是**数据竞态**问题。尽管很多场景下的通信我们都可以通过消息传递来解决，但是有些场景综合考量后还是必须使用共享内存的方式，毫无疑问，语言设计者需要两者兼顾。

#### 

> **数据竞态**:两个及以上线程并发读写同一个变量，并且至少其中有一个是写入时，称为数据竞态
>
> 避免数据竞态的三种方法：
>
> 1. 不要修改变量，只读取，不写入
> 2. 避免从多个线程访问变量
> 3. 互斥机制，允许多个线程访问同一个变量，但在同一时间，只允许一个线程可以访问



## Rust

起初，Rust 团队认为确保内存安全和防止并发问题是两个分别需要不同方法应对的挑战。随着时间的推移，团队发现所有权和类型系统是一系列解决**内存安全**和**并发问题**的强有力的工具。

Rust两种在线程间传送数据的方式：消息传递和共享状态。介绍之前，看一下线程的定义。



### 线程

Rust使用 `spawn` 创建新线程，创建时需要定义一个闭包，定义在新线程中运行的程序：

```rust
use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
    });
   	handle.join.unwrap();
}
```

如上，即定义了新的线程，`thread::spawn` 的返回值类型是 `JoinHandle`。`JoinHandle` 是一个拥有所有权的值，当对其调用 `join` 方法时，它会等待其线程结束。之前在介绍闭包时，我们曾提到一个问题，闭包使用作用域内的变量相应的有三种方式，移动(`move`)，不可变借用(`&`)，可变借用(`& mut`)，主线程理论上可能使新建线程的引用无效,为了避免线程中引用的变量失效，编译器强制要将变量的使用权移交给闭包，使用`move`关键字：

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];
  
    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```



### 消息传递

Rust 中一个实现消息传递并发的主要工具是**通道**(channel)，`mpsc::channel` 函数返回一个元组：第一个元素是发送端，而第二个元素是接收端：

```rust
use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

`send` 函数获取其参数的所有权并移动这个值归接收者所有。这个意味着不可能意外的在发送后再次使用这个值；所有权系统检查一切是否合乎规则。上面是一个没有具体使用场景的示例，仅为了说明通道的语法和作用方式，通过创建通道，发送变量，移交所有权，完成两个线程间通信。



### 共享状态

在某种程度上，任何编程语言中的通道都类似于单所有权，因为一旦将一个值传送到通道中，将无法再使用这个值。共享内存类似于多所有权：多个线程可以同时访问相同的内存位置，通常使用互斥锁来同步不同线程对变量的访问。但是锁的管理是非常复杂的问题，如果获取锁之后，由于遗忘或者异常没有释放锁，其他线程只能永远处于等待状态，在 Rust 中，得益于类型系统和所有权，不会在锁和解锁上出错，以标准库中的互斥器`Mutex`为例进行说明：

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());
}
```

使用 `lock` 方法获取锁，以访问互斥器中的数据，`lock` 调用 **返回** 一个叫做 `MutexGuard` 的智能指针。这个智能指针实现了 `Deref` 来指向其内部数据；其也提供了一个 `Drop` 实现，当 `MutexGuard` 离开作用域时自动释放锁。

在上面的示例中，看到有`Arc`的使用，在线程小节中提到，互斥器的所有权被`move`到第一个闭包中，其他的闭包引用互斥器的话就会出现问题，这需要使用多所有权手段来解决。 `Arc`是一个可以安全的用于并发环境的类型，是一个**原子引用计数**（*atomically reference counted*）类型。





Rust 提供了用于消息传递的通道，和像 `Mutex<T>` 和 `Arc<T>` 这样可以安全的用于并发上下文的智能指针。Rust的类型系统和借用检查器会确保并发场景中不会出现数据竞争和无效的引用，一旦编译通过，就可以坚信这些代码可以正确的运行于多线程环境，而不会出现其他语言中经常出现的那些难以追踪的问题。



## Go

Go语言有一句箴言：**不要通过共享内存来通信，而应该通过通信来共享内存**。Go中有两个定义需要着重理解，**Goroutine**和**Channel**：

- Goroutine：在Go中，每一个并发的执行单元叫作一个goroutine
- Channel：goroutine是Go中并发的执行体，那么通道就是它们之间的连接，通道是可以让一个goroutine发送特定值到另一个goroutine的通信机制，后面将不对Go的channel进行介绍，重点介绍使用共享变量实现并发的方式。



### goroutine

goroutine可以和线程类比，但是还是有几点差异

1. 可增长的栈

   为goroutine分配的栈的内存大小是按需分配的

2. 调度方式

   Go运行时包含一个自己的调度器对goroutine进行调度，这与OS的调度器相区别，有点是可以减少线程切换时OS切换上下文的开销

3. 线程模式

   编程语言提供的线程被称为 **绿色**（*green*）线程，使用绿色线程的语言会在不同数量的 OS 线程的上下文中执行它们。为此，绿色线程模式被称为 *M:N* 模型：`M` 个绿色线程对应 `N` 个 OS 线程，这里 `M` 和 `N` 不必相同。Go调度器使用`GOMAXPROCS`参数来确定`N`,正在休眠或正在被通信通信通道阻塞的goroutine不需要占用OS线程。

4. 标识

   goroutine没有可供访问的标示

   

### 使用共享变量实现并发

互斥锁也是Go用来访问共享变量的方式，上面提到，对释放锁的控制是这种互斥锁模式中需要注意的一点，Go中的延迟执行函数`defer`可以优化这种锁释放的管理：

```go
func Balance() int{
  mu.Lock()
  defer mu.Unlock()
  return balance
}
```

上例中，`mu.Unlock()`会在`Balance`函数返回前执行。

Go针对不同的使用场景定义了几种不同的锁，`sync.Mutex`互斥锁，`sync.RWMutex`读写互斥锁，`sync.Once`延迟初始化。



## Python

很多人知道Pyhton有全局解释器锁GIL，Python为什么要加GIL，其实是为了解决代码在解释执行时的一致性问题，保证多个线程在同一时刻不会修改同一数据，并且在同一时刻所看到的数据值是相同的，GIL保证同时只能有一个线程可以执行，自然就保证了这个限制，但是很尴尬的是，GIL是一个进程锁，是用作互斥线程的机制，这就导致python支持创建多线程，但是不支持同时执行多个线程，由于GIL的存在，同一时刻，只有一个线程可以向前执行，但是不能在设计层面上避免竞态问题，不同线程交替执行，也可能对共享数据进行写操作，GIL只是保证了解释器层面的一致性，但是程序的数据一致性，需要开发者采用补充机制去控制，比如加锁等。



## Java

> Java的部分值得单独整理，3.28-3.29的周末两天找时间集中处理下，也会在每天的间隙补充一些零散的内容

首先来看 Java 中的线程定义，然后看 Java 设计了什么机制来解决共享资源的竞争



### Java 线程

在 Java 中，要想定义任务，只要实现 `Runnable` 接口并编写 `run()` 方法，使得该任务可以执行你的命令：

```java
public class SomeJob implements Runnable{
  public void run(){
    // do something here
  }
}
```

将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器,Thread构造器只需要一个Runnable对象。调用Thread对象的start()方法为该线程执行必需的初始化操作，然后调用Runnable的run()方法，以便在这个新线程中启动该任务。但仅仅是启动线程而已，主线程没有义务等待新线程执行完毕。

`java.util.concurrent` 包提供了执行器 `Executor` 管理 `Thread` 的对象。



- 从任务中产生返回值

`Runnable` 是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成时能够返回一个值，那么实现 ` Callable` 接口而不是 `Runnable` 接口，`Callable` 是一个具有类型参数的泛型，它的类型表示的是从方法 `call()`中返回的值，必须使用`ExecutorService.submit()` 方法调用它，`submit()` 方法会生产`Future`对象，可以使用 `isDone` 方法查询 `Future` 是否已经完成，当任务完成时，它具有一个结果，可以调用 `get()`方法来获取该结果。



- 线程指令的语意

  比如 start yield join 等

  `yield通知其他具有相同优先级的线程可以运行

  `join` 一个线程可以在其他线程之上调用 `join` 方法，其效果是等待一段时间直到第二个线程结束才继续执行

  

### 解决共享资源竞争

原子性和可视性

运用 `Brain` 同步规则：

如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么必须使用同步，并且，读写线程都必须使用相同的监视器同步。





java 以提供关键字 `synchronized` 及 `volatile`  的形式，为防止资源冲突提供了内置的支持。

- `synchronized`
- `volatile` : 可以获得简单的赋值与返回操作的原子性，`volatile` 会立即写入内存中

Java还包括显式的互斥机制，这种机制相比 `synchronized` 的优势是，某些操作失败后，可以使用 `finally`子句将系统维护在正确的状态。



最后来看一些具体的案例：

1. 如何一次锁多个互斥量且避免死锁



## 总结

对比看来，以上语言的并发编程设计可以分为三档，第一档Rust，编译器可以帮助开发者，消除潜在风险，第二档Java和Go，中规中矩，提供了各种工具，需要开发者自己做各种检查和合理使用，第三档Python，GIL的设计饱受诟病，确实也不冤，但是好在易用性，也有其他机制弥补GIL对线程的限制。





## reference

《Rust程序设计语言(第二版)》

[《Go程序设计语言》](https://book.douban.com/subject/27044219/)

[《Python学习手册(第四版)》](https://book.douban.com/subject/6049132/)

[《java编程思想》](https://book.douban.com/subject/2130190/)

《Effective Java(第3版)》

《Effective Python》

《Understanding the Python GIL》PPT
