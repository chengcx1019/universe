## 	Go

实现数据抽象和面向对象的途径极其灵活

自动化的内存管理

箴言：不要通过共享内存来通信，而应该通过通信来共享内存

### 特性

#### defer

- 当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行

- 可以在一个函数中执行多条defer语句，执行顺序与声明顺序相反

  > 释放资源的defer应该直接跟在请求资源的语句后

  ```go
  resp, err := http.Get(url)
  if err != nil {
    return err
  }
  defer resp.Body.close()
  ```

- 延迟执行的defer函数可以改变外层函数返回给调用者的结果

### 并发

Goroutine和Channel

#### Goroutine

主函数返回时，所有的goroutine都暴力的直接终结

> 在go中，每一个并发的执行单元叫作一个goroutine

以服务端和客户端为例，并发分两个层面，首先是服务可以处理多个客户端的请求，其次是在单个客户端的连接中也存在并发

go关键字申明goroutine，go后跟的函数的参数会在go语句自身执行时被求值

顺序通信进程CSP：并发模式，在不同的执行体间传递值

- [ ] goroutine和线程的本质区别

#### Channel

- 通道基本语法：

```go
ch := make(chan xxx) //申明，内置函数make创建一个通道，类型是（chan xxx）
ch <- some_value //发送操作
<- ch //接收操作
close(ch) //内置函数close关闭通道
```

结束时关闭每个通道不是必须的:

1. 通知完接收方所有数据已经发送完才需要关闭

2. 垃圾回收是根据是否可以访问来决定回收通道，而不是根据它是否关闭

    

- 单向通道：

```go
chan<- int //只能发送通道，该变量只能出现在<-左侧
<-chan int //只能接收通道，该变量只能出现在<-右侧
```



任何操作中将双向通道转成单向通道都是可行的，反之不行

- 缓冲通道

  创建通道时通过make的容量参数来设定

  ```go
  ch = make(chan string, 3)
  ```

- 并行循环

1. 无缓存通道

- 多路复用

  使用场景，可以对不同事件选择性进行响应，不会block后续流程，使用slecte可以实现对channel轮询

  > 当goroutine一直尝试向一个没有goroutine从中读取值的channel发送事件，被称为goroutine泄漏



### 基于共享变量的并发

#### 数据竞态

两个及以上goroutine并发读写同一个变量，并且至少其中有一个是写入时，称为数据竞态

避免数据竞态的三种方法：

1. 不要修改变量，只读取，不写入
2. 避免从多个goroutine访问变量
3. 互斥机制，允许多个goroutine访问同一个变量，但在同一时间，只允许一个goroutine可以访问

#### 互斥锁

#### 读写互斥锁

写锁是否需要抢占读锁，不然在写入时如何保持读的一致性，还是说允许读在一定程度上的延迟与之后

#### 延迟初始化

`sync.Once`,`Once`包含一个布尔变量和一个互斥量，布尔变量记录初始化步骤是否已经完成，互斥量则负责保护这个布尔变量和客户端的数据结构

#### 并发非阻塞缓存

- [ ] 如何在防止竞态的情况下，同时不损耗性能的优化，不把预期中并行的操作串行化



## RUST

> 注重性能、并行、内存安全,**所有权系统**是Rust最为与众不同的特性，它保证了RUST无需垃圾回收即可保障内存安全，重点关注下；
>
> java的垃圾回收：Jvm在java程序运行期间，必须时刻监控、遍历java对象树，以鉴别出堆上哪些变量不再被引用，在一定的时间周期到达时自动释放那些不被引用变量的内存，即Jvm 在运行着一个和实际程序完全无关的垃圾回收进程，为运行时开销

### RUST的内存管理

更直接的，rust如何回收堆和栈上的数据，存储在栈上的数据好理解，当离开作用域时被移出栈，那rust是如何回收堆上的数据呢，拥有内存的变量离开作用域时，内存被自动释放

#### 所有权系统

**所有权**是一个新的概念，它由三条所有权规则来定义：

1. Rust中的每一个值都有一个被称为其所有者的变量
2. 值有且只有一个所有者
3. 当所有者（变量）离开作用域，这个值将被丢弃

两次释放相同内存会导致内存污染，为避免此问题，rust会在拷贝被分配的内存时，将原变量标记为不再有效，这个操作称为移动，书中以字符串拷贝举例：

```rust
let s1 = String::from("hello");
let s2 = s1;// 	move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
println!("{}, world!", s1) //value borrowed here after move, compile error, borrow of moved value: `s1`
```

只拷贝指针、长度和容量而不拷贝数据看起来像是浅拷贝，rust所做的与此略有差异，拷贝`s1`到`s2`的同时会使原变量`s1`失效，这个操作称为移动（move）

如果复制的行为和clone没有区别，就没必要调用clone，比如对栈上的数据的复制

- [ ] 既然rust的每一个对象都已经实现了`Drop`，那么如何为类型增加`Copy`注解呢（这个问题目前暂时不会更新，等待9-15日的空闲时间再同步一下进度吧）

  

- 作用域

  Rust的每个对象都实现了一个名为`Drop`的trait（可以理解为java的 接口），`Drop`包含一个方法`drop()`，在任何对象离开作用域的时候，`drop`会被自动调用，从而释放自身的内存

- 移动

  - `move`

- 只在栈上的数据clone

  克隆会复制堆上的数据，这个操作往往会非常耗时，影响性能；但是像整型这种存储在栈上的数据

  * 所有整数类型，比如 `u32`。
  * 布尔类型，`bool`，它的值是 `true` 和 `false`。
  * 所有浮点数类型，比如 `f64`。
  * 字符类型，`char`。
  * 元组，当且仅当其包含的类型也都是 `Copy` 的时候。比如，`(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 就不是。
  * 

- 借用

  - 只读借用

    `&`地址**借**用（更准确的理解是borrow，而非refer）;

    借用对象而不是获取对象的所有权，使用值但不获取所有权，当<u>借用离开作用域时其指向的值不会被**丢弃**</u>（抑或说释放）;

    函数签名需要使用`&`来表明参数的类型是一个借用;

    在函数中，无法对借用的变量进行更改，如果需要更改的话，就需要使用可变借用；

    一个借用的作用域从声明的地方开始一直持续到最后一次使用为止

  - 可变借用

    `&mut`，可变借用可以对数据进行修改，前提是借用的值是可以更改的;

    可以有多个只读借用，但是**在特定作用域中的特定数据有且只有一个可变引用**（可变借用期间也禁止只读借用，不允许拥有者有任何操作）;

    **在变量已经有只读借用的前提下，不同同时拥有可变借用**

  - 悬垂引用(借用)

    在具有指针的语言中，释放内存时经常会有错误的保留这块内存的指针，指针指向的内容可能已经被分配给其他持有者

  总而言之，明确两点，一是在任意指定时间内，要么只能有一个可变借用，要么只能有多个不可变借用，二是引用必须总是有效

上面的内容只能说明为何是内存安全，对于并行，RUST会有哪些得天独厚的设计呢



### 生命周期

生命周期是RUST最与众不同的功能，**编译器为每个变量保留了一份生命周期的长度，如果引用的生命周期长于数据的生命周期**，编译器会报错

- [ ] (两者的长短又是如何比较的)

### 函数特性

#### 闭包

闭包是可以保存进变量或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值

### 



## 函数式编程

> 编程范式，类比面向对象编程，这种编程范式的两个重要思想，一是不可变性（Avoiding mutating state and side-effects），二是程序由函数组成

### 不可变性

不可变性带来的好处是什么

- 代码更易于理解和阅读，只需要关注你关心的代码，而不用担心状态在其他函数中被改动
- 可以在执行层面优化，函数间没有耦合，且运行结果不变，可以缓存和并行化

有的语言从编译器层面可以保证变量不被变更，但是对于那些在编译器层面没有强限制的语言又当如何，靠编程规范吗？

### 程序由函数组成

first class values of the language：核心特性是函数可以作为函数的参数、返回值，可以指定给变量，可以存储在数据结构中（满足以上四个条件的实体即该语言的first class values ，或称为first-class citizens）

函数可以作为变量或者存储在数据结构中，且可以作为函数参数



### Function or Method：函数和方法真的是同一个概念吗

```F#
let add x y = x + y 
is shorter for
let add = fun x y -> x + y

```

但是深究起来应该理解为一个 接收一个参数的函数 返回一个接受一个参数的函数：

```F#
let add = 
	fun x -> 
		fun y ->
			x + y
```

> 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。Currying的应用主要有两点，一是避免重复传参，二是函数的合成（限制是被合成的函数有相同的参数，包括个数和类型）



## python

- [ ] GIL缺陷（更准确说是局限性）

  GIL是全局解释器锁，是一个进程锁，是python解释器用作互斥线程的一种机制

- [ ] python的竞态，并发通信怎么做的

一直没有好好探索python语言设计的初衷与特点，趁着这篇文章分享一下相关的认知及观点











