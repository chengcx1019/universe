在计算机科学中，闭包（Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持一级函数（核心特性是函数可以作为函数的参数、返回值，可以指定给变量，可以存储在数据结构中）的编程语言中实现词法绑定的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定。



抛开语言去谈闭包，我觉得难以透彻理解这个概念，这里结合Rust，Pyhton，Go，Java,试着从不同的语言来理解闭包。从不同的语言来理解一个概念的意义是每一种语言都有自己独有的设计思路，尽管殊途同归，有时候我们只看重结果，但是通往结果的道路依然重要，我们可以看一下每条道路上的不同风景。



闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。人们疑问最多的是匿名函数与闭包的关系和区别是什么，很多场合下它们被用作同义词，但严格来讲匿名函数不可以使用自由变量，闭包可以理解为函数的实例，这个实例保存在内存的结构体中，记录了闭包申明时函数所需变量的值，闭包可以使用自由变量也可以不使用自由变量，当闭包自身弱化不使用自由变量时，从作用上看等同于匿名函数，有的语言的编译器发现闭包没有使用自由变量，不存关联的环境信息时，就不会为闭包在内存中分配结构体，闭包被优化为普通函数(这种编译技巧被称为函数跃升)，这时可以认为二者没有区别。

## RUST

rust函数定义:

```rust
fn simulated_expensive_calculation(num: u32) -> u32 {
     num
}

fn generate_workout(intensity: u32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);
}
```

不同于函数进行函数调用并将其结果存储在变量，定义一个闭包并存储在变量中:

```rust
fn generate_workout(intensity: u32) {
    let expensive_closure = |num| {
    	num
		};
  	expensive_closure(5);
}
```

`=`	之后的部分是闭包的定义，这个闭包有多于一个参数num，如果有多于一个参数，可以使用逗号分隔，比如 `|param1, param2|`,这个 `let` 语句意味着 `expensive_closure` 包含一个匿名函数的 **定义**，不是调用匿名函数的 **返回值**。调用闭包类似于调用函数，指定存放闭包定义的变量名并后跟包含期望使用的参数:`expensive_closure(5)`	.这样我们可以解决无效调用的问题，那么如果有连续的闭包调用时，可以使用缓存进一步减少多余的调用。

### 作用及设计目的

- 作为匿名函数使用
- 访问作用域内的变量

需要注意的是，由于Rust特有的内存管理方式，闭包使用作用域内的变量相应的有三种方式，移动(`move`)，不可变借用(`&`)，可用借用(`& mut`)，与之相匹配的Rust定义了三种`Fn trait`:

* `FnOnce`:消费从周围作用域捕获的变量，闭包周围的作用域被称为其 环境，*environment*。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 `Once` 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。
* `Fn` :从其环境获取不可变的借用值
* `FnMut`: 获取可变的借用值所以可以改变其环境



## Python

python支持闭包，python中的函数是一级对象。

闭包是一个与作用域强相关的定义，python比较特殊的一点是变量没有显示申明，所以作用域是python里的一个很重要的概念，在表达式中引用变量时，python解释器将按如下顺序遍历各作用域，以解析该引用：

1. 当前函数的作用域
2. 任何外围作用域
3. 包含当前代码的模块的作用域（即全局作用域）
4. 内置作用域

但是，给变量赋值时，规则有所不同。如果当前作用域已经定义了这个变量，那么该变量就会具备新值；若是当前作用域没有定义这个变量，python则会把这次赋值视为对该变量的定义。举例而言，如下：

```python
def outer():
    x='hello'
    y=' world'
    def inner():
        print(y)
        x ='goodbye'        
    inner()
    print(x+y)  # hello world
```

上面的代码中，`print(x)`将会输出"hello"，原因是，`inner`是闭包，对外围作用域的y进行访问，同时对`x`赋值，但是根据python赋值规则，`inner`内的操作是在内部作用域定义一个新的变量`x`,对外围作用域没有影响。当然了python是为了安全性故意这样设计的，为此python定义了`nonlocal`来解决这个问题：

```python
def outer():
    x='hello'
    y=' world'
    def inner():
        nonlocal x 
        print(y)
        x ='good night'
    inner()
    print(x+y)  # good night world
```

所以注意在python中使用闭包时的变量赋值。

## Go

Go支持，而且Go就是那种将匿名函数和和闭包不加区分的典型，在《Go程序设计语言》一书中，Go中对闭包的定义是，保存了一段代码同时拥有状态的函数变量通常称为闭包，闭包是引用了外部变量的匿名函数，这样的定义是容易混淆概念的，这个定义差到什么程度呢，匿名函数是没有引用外部变量的闭包，这样含糊的定义都要来得更好，实际这二者有关联，但严格来讲是不同的。



## JAVA

有人提出类的内部方法中引用了类的属性时，这也可以理解为闭包，这么理解的话，在定义上是没有问题的，类的实例对象确实就可以被认为是存储了函数入口地址和上下文环境的一种结构体，个人感觉大家不必过于纠结，闭包是在面向对象语言出现前就有的定义，最早是在1960年代中期被提出，那时针对的是函数式编程范式，即针对单个函数而言，类的实例对象的**方法**天然就符合了闭包的定义（但有点值得注意的是方法对自由变量的使用方式，这点Rust具有明显特征，类的实例对象方法显然天然的就是引用方式，引用了对象本身），对于Java而言，我们可以将定义放宽，将自由变量的定义放到该对象之外，认为类的实例方法引用了对象本身之外的其他自由变量时，即自由变量来自于对象外部，而不是方法的外部时，才认为是闭包。

《Java编程思想(第4版)》中有一句话说的很透彻，根据闭包的定义，内部类是面向对象的闭包。

## reference

《Rust程序设计语言(第二版)》

[《Go程序设计语言》](https://book.douban.com/subject/27044219/)

[《Python学习手册(第四版)》](https://book.douban.com/subject/6049132/)

[《java编程思想》](https://book.douban.com/subject/2130190/)



