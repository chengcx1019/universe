> 最近在做一些系统重构的工作，涉及一些接口与实现分离的工作，借机以 java 为例来说明多态、泛型相关的内容。原来打算在一篇独立文章中理解泛型，但是很难将他们分离开。在理解多态的过程中，无法避免要提到类型转换，类型识别，因而无法不讲泛型而单论多态。

  

> 20200413 鹏翀在枚举里实现接口这种花里胡哨的用法，确实让我耳目一新，枚举似乎是有可能据此定义一张服务网络。

  

开始之前，我想先摘录《Java 编程思想》中的一段话：

为了在自己的程序中有效的运用多态乃至面向对象技术，必须扩展自己的编程视野，使其不仅包括个别类的成员和消息，而且还要包括类与类之间的共同特性以及它们之间的关系，尽管这需要极大的努力，但是这样做是非常值得的，因为它可以带来很多成效：更快的程序开发过程，更好的代码组织，更好扩展的程序以及更容易的代码维护。

  

另外一句值得记住的话：不要过度设计，在有真实需要时再进行重构。  

  

面向对象程序设计中有三个基本特征，分别是数据抽象，继承和多态。

多态，通过分离做什么和怎么做，从另一角度（还有一个角度是什么）将接口和实现分离开，接口和内部类提供了将接口和实现分离的更加结构化方法。

多态也常称作动态绑定，后期绑定或运行时绑定，那么**绑定**的含义是:将一个方法调用同一个方法主体关联起来称作**绑定**。绑定方式分为两种：

- 前期绑定：在程序执行前进行绑定
- 后期绑定：在运行时根据对象的类型进行绑定

后期绑定的机制随语言不同会有所不同，但可以想象，不管怎样都需要在对象中安置某种类型信息。

  

## 多态


何时使用抽象类，何时使用接口，书中说，你不可能总是使用纯接口。基于昨天自己的处理，抽象类更适合于需要使用闭包的场景，基于当前的作用域不同的对象有不同的处理方式，关于闭包的理解可以参考另一篇[文章](https://changxin10m.com/postDetail/%2Fblog%2Fapi%2Fli-jie-bi-bao,51%2F) 。

  

### 向上转型

对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用，这种把某个对象的引用视为其基类型的引用的做法称做向上转型。无论是将其向上转型为普通类，还是抽象类，还是接口似乎不重要，表现出的行为是一致的。

  

向上转型可能会缩小接口。

纯粹的继承关系，导出类与基类的接口完全一致；但通常继承后会扩展接口，导出类中的接口扩展部分不能被基类访问，因此，一旦向上转型，就不能调用那些新方法。

  

### 向下转型及运行时类型识别

与向上转型是安全的不同，向下转型时必须有某种方法来确保向下转型的正确性，使我们不至于贸然转型到一种错误类型，进而发出该对象无法接受的消息。

向下转型会在运行期进行检查，这称为运行时类型识别（RTTI）

  

## 类型信息

在这一小节我们将了解 RTTI 在 java中的工作原理，类型信息在运行时是如何表示的。

  

### 获取Class对象引用

在 java 中，获取 Class 对象的引用方式有两种：

- `Class.forName`

  ```java
  Class clazzA = Class.forName("A");
  A a = clazzA.newInstance() //创建实例
  ```

  `Class.forName ` 获取Class的引用，创建实例需要使用 `class.newInstance() ` ，不过这种方式问题很大，编译时不受检查，需要进行异常处理

- 类字面常量

  java提供了另一种方式来生成对Class对象的引用，即类字面常量，`A.class` ，这种方式更简单，而且也更安全，可以在编译时就收到检查。



### 类型转换前先做检查



类型转换是伴随多态而时刻发生的，编译器允许自由地向上转型的赋值操作，而不需要任何显式的转型操作，但是在向下转型赋值时，需要**使用显示的类型转换**，以此表明开发者具有额外的信息来判断该类型是某种特定类型，**编译器将检查向下转型是否合理，它不允许向下转型到实际上不是待转类型的子类的类型上**。



java 中类型检查的方式有两种，关键字 `instanceof` 和 Class 对象的 `isInstance` 方法：

```java  
class A {
  f();
}
class B extends A{
  f();
  g();
}
A a = new B();
// `instanceof` 方式
if(a instanceof B){
  ((B)a).g();
}

//`isInstance` 方式
if(a.isInstance(B.class)){
   ((B)a).g();
}
```



综上所述，RTTI 表现为三种形式：

1. 运行时识别一个引用所指向对象的确切类型，
2. 通过 Class 对象获取所需要的信息
3. 使用 `instanceof` 做类型转换前检查

  

### 反射

RTTI 所能做的事是基于一个前提，那就是在编译阶段，编译器必须要知道所有要通过 RTTI 来处理的类。与RTTI不同的是，反射是在运行时检查，反射在创建更动态的代码时会有用，即运行时创建对象，需要用到反射。

  

## 泛型

内容终于来到本文的主角，泛型。





为了适配不同的类而额外定义的方法，如何做到不进行误用呢，可以在接口中抽象出更通用的方法，将实现类比较特殊的部分在该方法进行处理。



在接口中定义默认方法的意义是什么，为什么在后续的java版本中提供了接口默认方法的支持。





- [ ] 假设 `A extends B` , A是B的子类，但是 LIst<A> 不是 List<B> 的子类

  我们谈论的是容器的类型，而不是容器持有的类型，可以将List<A>传递给类型List的参数，但是不能将它传递给类型List<B>的参数

- [ ] 继承的类受接口实现限制吗，如果受的，这个属性是如何对继承类实现的，还是只是通过约束父类达到此目的





PECS

只要想清楚一点就比较明确了，你只能将类型向上转型，而不能将一个类型往不是它本身的子类转型，因而生产者只能生产待消费容器所固有类型的子类型，消费者作为承接元素的容器，也只能是其需要承接元素的超类，这样才可以避免类型转换的错误。





**理解自限定类型** 

将自己作为参数传递给基类的导出类

```java
interface SelfBoundSetter<T extends SelfBoundSetter<T>>{
  void set(T arg)
}

interface Setter extends SelfBoundSetter<Setter>{}
```

如果使用了自限定，只能获得某个方法的一个版本，，它将接受确切的参数类型，如果不使用自限定，将重载参数类型



extends 关键字在泛型边界上下文环境中和普通环境下所具有的意义是完全不同的，即 extends 关键字用于边界与用来创建子类是不同的