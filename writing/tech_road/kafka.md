what’s the difference between an event stream and a database table? Is a Kafka topic the same as a stream? How can I best leverage all these pieces when I want to put my data in Kafka to use?



## Events, streams, and tables





## 基本概念

存储，topics，partitions

设计上的优势：

1. kafka本身不对数据进行序列化和反序列化

2. 将生产者和消费者分离是另一个有利于扩展性的设计

   

**kafka 使用主题来存储数据，每个主题被分为若干个分区，每个分区有多个副本。副本被保存在 broker 上，每个broker 可以保存成百上千个属于不同主题和分区的副本。**





topics里的消息如何记录消费状态，或者说消费的模式是怎样的

brokers：一个独立的 kafka 服务器称为 broker 



kafka集群通过分区对主题进行横向扩展，为主题选定分区数量并不是一件可有可无的事情，需要考虑一下几个因素:

- 主题需要达到多大的吞吐量

需要多少个 broker，搭建集群的考量因素：

- 



scalability, elasticity, and fault tolerance





## 3生产者-向 kafka 写入消息

### 顺序保证

kafka 可以保证同一个分区的消息时有序的。

但是错误的情况有时无法保证，$retries$ 设为非零整数，同时把 $max.in.flght.requests.per.connection$ 设为比 1 大的数，那么，如果第一个批次消息写入失败，而第二个批次写入成功，broker 回重试写入第一个批次。如果此时第一个批次也写入成功，那么两个批次的顺序就反过来了。



一般来说如果某些场景要求消息是有序的，那么消息是否写入成功也很关键，$retries$ 不设为 0，$max.in.flght.requests.per.connection$ 设为 1，这样，生产者尝试发送第一批消息时，就不会有其他的消息发送给 broker。这样做的弊端是会严重影响生产者的吞吐量，所以只有在对消息的顺序有严格要求的情况下才能这么做。

### 序列化与反序列化

schema 注册表，序列化器和反序列化器分别负责处理 schema 的注册和拉取



### 分区

**拥有相同键的消息将会被写到同一个分区**，如果不指定键，那么记录将随机的发送到主题内各个可用的分区上。分区器使用轮询（Round Robin）算法将消息均衡地分布到各个分区上。

#### 配置



## 4消费者

消费者和消费者群组

一个群组里的消费者订阅的是同一个主题，每个消费者接受主题一部分分区消息

？同一个docker服务下的多个 pod 对同一主题是如何消费的，何为不同的消费者



#### 安全的再均衡

#### 轮询

群组协调，分区再平衡，发送心跳和获取数据



#### 配置

$auto.offset.reset$ :

#### 提交和偏移量



#### 再均衡监听器



## 5深入kafka

#### 控制器

#### 复制

分布式的、可分区的、可复制的提交日志服务，复制如此关键的原因是因为它可以在个别节点失效时仍能保证 kafka 的可用性和持久性

##### 首领副本和跟随者副本

每个分区都有一个首领副本。为了保证一致性，所有生产者的请求和消费者请求都会经过这个副本。

首领以外的副本都是跟随者副本。跟随者副本不处理来自客户端的请求，他们唯一的任务就是从首领那里复制消息，保持与首领一致的状态。如果首领发生崩溃，其中的一个跟随者会被提升为新首领。



首领副本的另一个任务是搞清楚哪个跟随者的状态与自己是一致的。如果一个副本无法与首领保持一致，在首领发生失效的时，它就不可能成为新首领



## 6可靠的数据传递



### 复制和分区可用性



## 事务



## 同类产品对比

RocketMQ

特点：解耦、削峰填谷（在面临流量的不确定性时，实现对流量的缓冲处理）

存储形式

存储可靠性

顺序消息

延时消息

消息重复

消息过滤

消息失败重试

DLQ（dead letter queue）

回溯消费

事务

 

服务发现

高可用

