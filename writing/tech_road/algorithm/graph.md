# 图

如何用图思考[原文](https://medium.freecodecamp.org/i-dont-understand-graph-theory-1c96572a1401)

为了方便描述，有如下定义：

$G=(V,E)$ 定义图，其中 $V$ 代表顶点集合， $E$ 代表边集合

对图的操作可以分为以下三类：

- `create` : 生成
- `inspect` 查询或判定，判断图是否为有向图，给定顶点返回所有邻接边等
- `update` : 更新，添加顶点或边




## 图的表示

- 邻接数组-静态图

- 邻接表-动态图

- 邻接矩阵

## 图的遍历

> 相比广度优先使用队列存储未访问的邻接节点，深度遍历的循环实现方式使用栈存储当前节点的未访问邻接节点



### 广度优先搜索

广度优先搜索从边上来说，都是从源点到图中任意顶点的最短路径



### 深度优先搜索



顶点访问顺序会改变计数器的值，所以需要注意临接节点的顺序，深度优先搜索计算出来的结果非常有用，包括**拓扑排序**，寻找**强连通部**，寻找网络中潜在的弱点。

深度优先搜索结束后，可以使用每个顶点存储的前序节点值找到一条从**任意顶点到原点s的路径**，当然，这条路径也许不是最短路径。

深度优先搜索仅仅依靠当前信息，是一种盲目的搜索，它没有一个明智的计划来快速达到目标顶点t。



算法分析：

- 对于有向图，点和边都会被访问一次

- 对于无向图，对每个顶点都需要回去检查一次，顶点和边都被访问了两次

  综上，算法复杂度为 `O(V+E)` 



### 边的分类

根据在图G上进行深度优先搜索所产生的深度优先森林

- 树边(tree edge)
- 反向边(back edge)
- 正向边(forward edge)
- 交叉边(cross edge)





## 典型问题描述

### 最小生成树

给定无向连通图$G=(V,E)$ (无向带权重)，最小生成树：（1）包含图中的所有定点，（2）所有边的权重之和是最小的，典型算法 `Prime `, 实现 `Prime` 算法的过程中需要用的优先队列，选择最小权重边



```text
## 深度优先搜索的应用

## 有向无环图中的拓扑排序

## 有向图中计算强连通分量



### 最短路径

有向无环图

#### 单源最短路径

##### 非负边代价（Dijkstra）

##### 任意边代价（Bellman-Ford）

不可包含总权值为负值的环

#### 任意两个顶点间最短路径

动态规划Floyd-Warshall

### 最小生成树

给定无向连通图$G=(V,E)$

#### 关于图的其他

- 欧拉回路(不重复经过所有边)和曼哈顿回路(不重复经过所有点)
```











## 多任务拓扑关系初步设计

通过order_id关联图的所有节点（没有order关联即单几点），通过新增一张表维护有向边，source，dest，order_id(source，dest为task_id)，为了扩展性，包含边的权重



## reference

https://github.com/kamyu104/LeetCode.git

https://github.com/hickford/codejam.git