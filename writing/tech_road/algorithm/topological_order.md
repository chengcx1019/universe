> 工作需要，为了向同事表达清楚观点，提高行动力，整理下思路。

拓扑排序：在计算机科学中，有向图的拓扑排序是其顶点的线性排序，使得对于从顶点 `u` 到顶点 `v` 的每个有向边`uv` ，`u` 的排序都在 `v` 前。在实际应用过程中，图的顶点可以表示待执行的任务，边可以表示一个任务必须在另一个任务之前执行的约束，在此应用中，拓扑排序只是一个有效的任务顺序。

执行拓扑排序有一个限制，当且仅当图中没有定向环时，才有可能进行拓扑排序。

任何有向无环图至少有一个拓扑排序，可以在线性时间内，构建任何有向无环图的拓扑排序。



目前实现拓扑排序的常用的算法有卡恩算法和深度优先搜索。



## 卡恩算法

算法流程：

1. 从图中选择一个入度为0的顶点，输出该顶点。
2. 从图中删除该节点及其所有出边（即与之邻接的所有顶点入度-1）
3. 反复执行1和2，直至所有节点输出，如果最后图中还有入度不为0的顶点，那么说明图中有回路，不能进行拓扑排序



### 伪码描述

```text
L ← 包含已排序的元素的列表，目前为空
S ← 入度为零的节点的集合
当 S 非空时：
    将节点n从S移走
    将n加到L尾部
    选出任意起点为n的边e = (n,m)，移除e。如m没有其它入边，则将m加入S。
    重复上一步。
如图中有剩余的边则：
    return error   (图中至少有一个环)
否则： 
    return L   (L为图的拓扑排序)
```









## 深度优先搜索

算法流程：

1. 对图执行深度优先搜索。
2. 在执行深度优先搜索时，若某个顶点不能继续前进，即顶点的出度为0，则将此顶点入栈。
3. 最后得到栈中顺序的逆序即为拓扑排序顺序。



伪码描述：

```text
L ← 包含已排序的元素的列表，目前为空
当图中存在未永久标记的节点时：
    选出任何未永久标记的节点n
    visit(n)
    
function visit(节点 n)
    如n已有永久标记：
        return
    如n已有临时标记：
        stop   (不是定向无环图)
    将n临时标记
    选出以n为起点的边(n,m)，visit(m)
    重复上一步
    去掉n的临时标记
    将n永久标记
    将n加到L的起始
```



> 待早上起来实现一版